// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Perform a test connection check to validate the server exists
    ///
    /// - Remark: HTTP `GET /ok`.
    /// - Remark: Generated from `#/paths//ok/get(ok)`.
    func ok(_ input: Operations.Ok.Input) async throws -> Operations.Ok.Output
    /// Send an array of emails to the Email Server Gateway with credentials for queued processing
    ///
    /// - Remark: HTTP `POST /smtp/queue`.
    /// - Remark: Generated from `#/paths//smtp/queue/post(smtp/queue)`.
    func smtpQueue(_ input: Operations.SmtpQueue.Input) async throws -> Operations.SmtpQueue.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Perform a test connection check to validate the server exists
    ///
    /// - Remark: HTTP `GET /ok`.
    /// - Remark: Generated from `#/paths//ok/get(ok)`.
    public func ok() async throws -> Operations.Ok.Output {
        try await ok(Operations.Ok.Input())
    }
    /// Send an array of emails to the Email Server Gateway with credentials for queued processing
    ///
    /// - Remark: HTTP `POST /smtp/queue`.
    /// - Remark: Generated from `#/paths//smtp/queue/post(smtp/queue)`.
    public func smtpQueue(
        headers: Operations.SmtpQueue.Input.Headers,
        body: Operations.SmtpQueue.Input.Body
    ) async throws -> Operations.SmtpQueue.Output {
        try await smtpQueue(Operations.SmtpQueue.Input(
            headers: headers,
            body: body
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    /// local vapor server
    public enum Server1 {
        /// local vapor server
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "http://12.0.0.1:8081/",
                variables: []
            )
        }
    }
    /// local vapor server
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "http://12.0.0.1:8081/",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// A simple SMTP email sent through SwiftMail to an SMTP server
        ///
        /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail`.
        public struct SimpleSMTPEmail: Codable, Hashable, Sendable {
            /// The sender of the email
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/sender`.
            public var sender: Components.Schemas.EmailAddress
            /// The primary recepients of the email
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/recepients`.
            public var recepients: [Components.Schemas.EmailAddress]
            /// The primary recepients of the email
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/cc_recepients`.
            public var ccRecepients: [Components.Schemas.EmailAddress]
            /// The primary recepients of the email
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/bcc_recepients`.
            public var bccRecepients: [Components.Schemas.EmailAddress]
            /// The subject of the email.
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/subject`.
            public var subject: Swift.String
            /// The plain text body of the email
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/text_body`.
            public var textBody: Swift.String
            /// The HTML body of the email (optional)
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/html_body`.
            public var htmlBody: Swift.String?
            /// An array of attachments to send
            ///
            /// - Remark: Generated from `#/components/schemas/SimpleSMTPEmail/attachments`.
            public var attachments: [Components.Schemas.Attachment]
            /// Creates a new `SimpleSMTPEmail`.
            ///
            /// - Parameters:
            ///   - sender: The sender of the email
            ///   - recepients: The primary recepients of the email
            ///   - ccRecepients: The primary recepients of the email
            ///   - bccRecepients: The primary recepients of the email
            ///   - subject: The subject of the email.
            ///   - textBody: The plain text body of the email
            ///   - htmlBody: The HTML body of the email (optional)
            ///   - attachments: An array of attachments to send
            public init(
                sender: Components.Schemas.EmailAddress,
                recepients: [Components.Schemas.EmailAddress],
                ccRecepients: [Components.Schemas.EmailAddress],
                bccRecepients: [Components.Schemas.EmailAddress],
                subject: Swift.String,
                textBody: Swift.String,
                htmlBody: Swift.String? = nil,
                attachments: [Components.Schemas.Attachment]
            ) {
                self.sender = sender
                self.recepients = recepients
                self.ccRecepients = ccRecepients
                self.bccRecepients = bccRecepients
                self.subject = subject
                self.textBody = textBody
                self.htmlBody = htmlBody
                self.attachments = attachments
            }
            public enum CodingKeys: String, CodingKey {
                case sender
                case recepients
                case ccRecepients = "cc_recepients"
                case bccRecepients = "bcc_recepients"
                case subject
                case textBody = "text_body"
                case htmlBody = "html_body"
                case attachments
            }
        }
        /// An email Attachment
        ///
        /// - Remark: Generated from `#/components/schemas/Attachment`.
        public struct Attachment: Codable, Hashable, Sendable {
            /// The filename of the attachment
            ///
            /// - Remark: Generated from `#/components/schemas/Attachment/file_name`.
            public var fileName: Swift.String
            /// The MIME type of the attachment
            ///
            /// - Remark: Generated from `#/components/schemas/Attachment/mime_type`.
            public var mimeType: Swift.String
            /// The data of the attachment
            ///
            /// - Remark: Generated from `#/components/schemas/Attachment/data`.
            public var data: Swift.String
            /// Optional content ID for inline attachments
            ///
            /// - Remark: Generated from `#/components/schemas/Attachment/content_id`.
            public var contentId: OpenAPIRuntime.OpenAPIValueContainer?
            /// Whether this attachment should be displayed inline
            ///
            /// - Remark: Generated from `#/components/schemas/Attachment/is_inline`.
            public var isInline: Swift.Bool
            /// Creates a new `Attachment`.
            ///
            /// - Parameters:
            ///   - fileName: The filename of the attachment
            ///   - mimeType: The MIME type of the attachment
            ///   - data: The data of the attachment
            ///   - contentId: Optional content ID for inline attachments
            ///   - isInline: Whether this attachment should be displayed inline
            public init(
                fileName: Swift.String,
                mimeType: Swift.String,
                data: Swift.String,
                contentId: OpenAPIRuntime.OpenAPIValueContainer? = nil,
                isInline: Swift.Bool
            ) {
                self.fileName = fileName
                self.mimeType = mimeType
                self.data = data
                self.contentId = contentId
                self.isInline = isInline
            }
            public enum CodingKeys: String, CodingKey {
                case fileName = "file_name"
                case mimeType = "mime_type"
                case data
                case contentId = "content_id"
                case isInline = "is_inline"
            }
        }
        /// An email address object
        ///
        /// - Remark: Generated from `#/components/schemas/EmailAddress`.
        public struct EmailAddress: Codable, Hashable, Sendable {
            /// The presentable email address name
            ///
            /// - Remark: Generated from `#/components/schemas/EmailAddress/name`.
            public var name: Swift.String?
            /// The email address itself
            ///
            /// - Remark: Generated from `#/components/schemas/EmailAddress/address`.
            public var address: Swift.String
            /// Creates a new `EmailAddress`.
            ///
            /// - Parameters:
            ///   - name: The presentable email address name
            ///   - address: The email address itself
            public init(
                name: Swift.String? = nil,
                address: Swift.String
            ) {
                self.name = name
                self.address = address
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case address
            }
        }
        /// Information about a mailbox from a LIST command
        ///
        /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo`.
        public struct IMAPMailboxInfo: Codable, Hashable, Sendable {
            /// The name of the mailbox
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/name`.
            public var name: Swift.String
            /// The attributes of the mailbox
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/attributes`.
            public var attributes: [Components.Schemas.IMAPMailboxAttributes]
            /// The hierarchy delimiter used by the server
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/hierarchy_delimiter`.
            public var hierarchyDelimiter: Swift.String?
            /// Whether the mailbox can be selected
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/is_selectable`.
            public var isSelectable: Swift.Bool
            /// Whether the mailbox has child mailboxes
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/has_children`.
            public var hasChildren: Swift.Bool
            /// Whether the mailbox has no child mailboxes
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/has_no_children`.
            public var hasNoChildren: Swift.Bool
            /// Whether the mailbox is marked
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/is_marked`.
            public var isMarked: Swift.Bool
            /// Whether the mailbox is umarked
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxInfo/is_unmarked`.
            public var isUnmarked: Swift.Bool
            /// Creates a new `IMAPMailboxInfo`.
            ///
            /// - Parameters:
            ///   - name: The name of the mailbox
            ///   - attributes: The attributes of the mailbox
            ///   - hierarchyDelimiter: The hierarchy delimiter used by the server
            ///   - isSelectable: Whether the mailbox can be selected
            ///   - hasChildren: Whether the mailbox has child mailboxes
            ///   - hasNoChildren: Whether the mailbox has no child mailboxes
            ///   - isMarked: Whether the mailbox is marked
            ///   - isUnmarked: Whether the mailbox is umarked
            public init(
                name: Swift.String,
                attributes: [Components.Schemas.IMAPMailboxAttributes],
                hierarchyDelimiter: Swift.String? = nil,
                isSelectable: Swift.Bool,
                hasChildren: Swift.Bool,
                hasNoChildren: Swift.Bool,
                isMarked: Swift.Bool,
                isUnmarked: Swift.Bool
            ) {
                self.name = name
                self.attributes = attributes
                self.hierarchyDelimiter = hierarchyDelimiter
                self.isSelectable = isSelectable
                self.hasChildren = hasChildren
                self.hasNoChildren = hasNoChildren
                self.isMarked = isMarked
                self.isUnmarked = isUnmarked
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case attributes
                case hierarchyDelimiter = "hierarchy_delimiter"
                case isSelectable = "is_selectable"
                case hasChildren = "has_children"
                case hasNoChildren = "has_no_children"
                case isMarked = "is_marked"
                case isUnmarked = "is_unmarked"
            }
        }
        /// Mailbox attributes that may be requested and returned as part of a *LIST* command.
        ///
        /// - Remark: Generated from `#/components/schemas/IMAPMailboxAttributes`.
        @frozen public enum IMAPMailboxAttributes: String, Codable, Hashable, Sendable, CaseIterable {
            case messageCount = "message_count"
            case recentCount = "recent_count"
            case uidNext = "uid_next"
            case uidValidity = "uid_validity"
            case unseenCount = "unseen_count"
            case size = "size"
            case highestModificationSequence = "highest_modification_sequence"
            case appendLimit = "append_limit"
            case mailboxId = "mailbox_id"
        }
        /// Set of information about the IMAP mailbox. None are guaranteed.
        ///
        /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus`.
        public struct IMAPMailboxStatus: Codable, Hashable, Sendable {
            /// MESSAGES The number of messages in the mailbox.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/message_count`.
            public var messageCount: Swift.Int?
            /// RECENT The number of messages with the \Recent flag set.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/recent_count`.
            public var recentCount: Swift.Int?
            /// UIDNEXT The next unique identifier value of the mailbox.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/next_uid`.
            public var nextUid: Swift.Int?
            /// UIDVALIDITY The unique identifier validity value of the mailbox.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/uid_validity`.
            public var uidValidity: Swift.Int?
            /// UNSEEN The number of messages which do not have the \Seen flag set.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/unseen_count`.
            public var unseenCount: Swift.Int?
            /// SIZE RFC8438 The total size of the mailbox in octets.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/size`.
            public var size: Swift.Int?
            /// HIGHESTMODSEQ RFC 7162 INT64 The highest mod-sequence value of all messages in the mailbox.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/highest_modification_sequence`.
            public var highestModificationSequence: Swift.Int?
            /// APPENDLIMIT RFC 7889 per-mailbox APPENDLIMIT, i.e. maximum message upload size.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/append_limit`.
            public var appendLimit: Swift.Int?
            /// MAILBOXID RFC 8474 object ID of the mailbox.
            ///
            /// - Remark: Generated from `#/components/schemas/IMAPMailboxStatus/mailbox_id`.
            public var mailboxId: Swift.Int?
            /// Creates a new `IMAPMailboxStatus`.
            ///
            /// - Parameters:
            ///   - messageCount: MESSAGES The number of messages in the mailbox.
            ///   - recentCount: RECENT The number of messages with the \Recent flag set.
            ///   - nextUid: UIDNEXT The next unique identifier value of the mailbox.
            ///   - uidValidity: UIDVALIDITY The unique identifier validity value of the mailbox.
            ///   - unseenCount: UNSEEN The number of messages which do not have the \Seen flag set.
            ///   - size: SIZE RFC8438 The total size of the mailbox in octets.
            ///   - highestModificationSequence: HIGHESTMODSEQ RFC 7162 INT64 The highest mod-sequence value of all messages in the mailbox.
            ///   - appendLimit: APPENDLIMIT RFC 7889 per-mailbox APPENDLIMIT, i.e. maximum message upload size.
            ///   - mailboxId: MAILBOXID RFC 8474 object ID of the mailbox.
            public init(
                messageCount: Swift.Int? = nil,
                recentCount: Swift.Int? = nil,
                nextUid: Swift.Int? = nil,
                uidValidity: Swift.Int? = nil,
                unseenCount: Swift.Int? = nil,
                size: Swift.Int? = nil,
                highestModificationSequence: Swift.Int? = nil,
                appendLimit: Swift.Int? = nil,
                mailboxId: Swift.Int? = nil
            ) {
                self.messageCount = messageCount
                self.recentCount = recentCount
                self.nextUid = nextUid
                self.uidValidity = uidValidity
                self.unseenCount = unseenCount
                self.size = size
                self.highestModificationSequence = highestModificationSequence
                self.appendLimit = appendLimit
                self.mailboxId = mailboxId
            }
            public enum CodingKeys: String, CodingKey {
                case messageCount = "message_count"
                case recentCount = "recent_count"
                case nextUid = "next_uid"
                case uidValidity = "uid_validity"
                case unseenCount = "unseen_count"
                case size
                case highestModificationSequence = "highest_modification_sequence"
                case appendLimit = "append_limit"
                case mailboxId = "mailbox_id"
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {
        /// - Remark: Generated from `#/components/parameters/SMTPUsername`.
        public typealias SMTPUsername = Swift.String
        /// - Remark: Generated from `#/components/parameters/SMTPPassword`.
        public typealias SMTPPassword = Swift.String
        /// - Remark: Generated from `#/components/parameters/SMTPProvider`.
        @frozen public enum SMTPProvider: String, Codable, Hashable, Sendable, CaseIterable {
            case googleSmtp = "google_smtp"
            case googleSmtpRelay = "google_smtp_relay"
            case yahoo = "yahoo"
        }
    }
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {}
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Perform a test connection check to validate the server exists
    ///
    /// - Remark: HTTP `GET /ok`.
    /// - Remark: Generated from `#/paths//ok/get(ok)`.
    public enum Ok {
        public static let id: Swift.String = "ok"
        public struct Input: Sendable, Hashable {
            /// Creates a new `Input`.
            public init() {}
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successfully connected to server
            ///
            /// - Remark: Generated from `#/paths//ok/get(ok)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Ok.Output.Ok)
            /// Successfully connected to server
            ///
            /// - Remark: Generated from `#/paths//ok/get(ok)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Ok.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Send an array of emails to the Email Server Gateway with credentials for queued processing
    ///
    /// - Remark: HTTP `POST /smtp/queue`.
    /// - Remark: Generated from `#/paths//smtp/queue/post(smtp/queue)`.
    public enum SmtpQueue {
        public static let id: Swift.String = "smtp/queue"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/smtp/queue/POST/header`.
            public struct Headers: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/SMTPProvider`.
                @frozen public enum SMTPProvider: String, Codable, Hashable, Sendable, CaseIterable {
                    case googleSmtp = "google_smtp"
                    case googleSmtpRelay = "google_smtp_relay"
                    case yahoo = "yahoo"
                }
                /// - Remark: Generated from `#/paths/smtp/queue/POST/header/smtp-provider`.
                public var smtpProvider: Components.Parameters.SMTPProvider
                /// - Remark: Generated from `#/paths/smtp/queue/POST/header/smtp-username`.
                public var smtpUsername: Components.Parameters.SMTPUsername
                /// - Remark: Generated from `#/paths/smtp/queue/POST/header/smtp-password`.
                public var smtpPassword: Components.Parameters.SMTPPassword
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - smtpProvider:
                ///   - smtpUsername:
                ///   - smtpPassword:
                public init(
                    smtpProvider: Components.Parameters.SMTPProvider,
                    smtpUsername: Components.Parameters.SMTPUsername,
                    smtpPassword: Components.Parameters.SMTPPassword
                ) {
                    self.smtpProvider = smtpProvider
                    self.smtpUsername = smtpUsername
                    self.smtpPassword = smtpPassword
                }
            }
            public var headers: Operations.SmtpQueue.Input.Headers
            /// - Remark: Generated from `#/paths/smtp/queue/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/smtp/queue/POST/requestBody/content/application\/json`.
                case json([Components.Schemas.SimpleSMTPEmail])
            }
            public var body: Operations.SmtpQueue.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.SmtpQueue.Input.Headers,
                body: Operations.SmtpQueue.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// Creates a new `Ok`.
                public init() {}
            }
            /// Successfully queued all requested emails and have begun processing
            ///
            /// - Remark: Generated from `#/paths//smtp/queue/post(smtp/queue)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.SmtpQueue.Output.Ok)
            /// Successfully queued all requested emails and have begun processing
            ///
            /// - Remark: Generated from `#/paths//smtp/queue/post(smtp/queue)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            public static var ok: Self {
                .ok(.init())
            }
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.SmtpQueue.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct InternalServerError: Sendable, Hashable {
                /// Creates a new `InternalServerError`.
                public init() {}
            }
            /// An error occurred when queuing emails.
            ///
            /// - Remark: Generated from `#/paths//smtp/queue/post(smtp/queue)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Operations.SmtpQueue.Output.InternalServerError)
            /// An error occurred when queuing emails.
            ///
            /// - Remark: Generated from `#/paths//smtp/queue/post(smtp/queue)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            public static var internalServerError: Self {
                .internalServerError(.init())
            }
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Operations.SmtpQueue.Output.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
}
